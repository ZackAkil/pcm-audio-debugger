<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Base64 PCM Audio Decoder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      @font-face {
        font-family: 'LucideIcons';
        src: url(https://cdn.jsdelivr.net/npm/lucide-static@latest/font/Lucide.ttf) format('truetype');
      }
      .lucide {
        font-family: 'LucideIcons';
        font-size: 1.25rem; /* Adjust icon size as needed */
        line-height: 1;
        display: inline-block;
        font-style: normal;
        font-weight: normal;
        font-variant: normal;
        text-rendering: auto;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      /* Simple loading spinner */
      .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        width: 24px;
        height: 24px;
        border-radius: 50%;
        border-left-color: #09f;
        animation: spin 1s ease infinite;
        display: inline-block;
        margin-right: 8px;
        vertical-align: middle;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    </style>
    <script>
        // Initialize Tailwind CSS
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
</head>
<body class="bg-gray-100 font-sans flex items-center justify-center min-h-screen p-4">

    <div class="bg-white p-8 rounded-lg shadow-lg w-full max-w-2xl">
        <h1 class="text-2xl font-bold mb-6 text-center text-gray-800">Base64 PCM Audio Decoder</h1>

        <div class="mb-4">
            <label for="base64Input" class="block text-sm font-medium text-gray-700 mb-1">Paste Base64 Audio Data:</label>
            <textarea id="base64Input" rows="6" class="w-full p-3 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500 shadow-sm" placeholder="Paste your Base64 encoded PCM audio here..."></textarea>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <div>
                <label for="sampleRate" class="block text-sm font-medium text-gray-700 mb-1">Sample Rate (Hz):</label>
                <input type="number" id="sampleRate" value="44100" class="w-full p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500 shadow-sm" placeholder="e.g., 44100">
            </div>
            <div>
                <label for="channels" class="block text-sm font-medium text-gray-700 mb-1">Channels:</label>
                <select id="channels" class="w-full p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500 shadow-sm bg-white">
                    <option value="1" selected>1 (Mono)</option>
                    <option value="2">2 (Stereo)</option>
                </select>
            </div>
            <div>
                <label for="bitDepth" class="block text-sm font-medium text-gray-700 mb-1">Bit Depth / Format:</label>
                <select id="bitDepth" class="w-full p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500 shadow-sm bg-white">
                    <option value="8u" selected>8-bit Unsigned Int</option>
                    <option value="16s">16-bit Signed Int (LE)</option>
                    <option value="32f">32-bit Float (LE)</option>
                    </select>
            </div>
        </div>

        <div class="text-center mb-4">
            <button id="playButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-md shadow-md transition duration-150 ease-in-out inline-flex items-center disabled:opacity-50 disabled:cursor-not-allowed">
                 <span class="lucide mr-2">&#xea48;</span>
                Decode & Play
            </button>
        </div>

        <div id="statusArea" class="mt-4 p-3 text-center text-sm rounded-md min-h-[40px]" role="alert">
            </div>

    </div>

    <script>
        const base64Input = document.getElementById('base64Input');
        const sampleRateInput = document.getElementById('sampleRate');
        const channelsInput = document.getElementById('channels');
        const bitDepthInput = document.getElementById('bitDepth');
        const playButton = document.getElementById('playButton');
        const statusArea = document.getElementById('statusArea');

        let audioContext; // Reuse AudioContext
        let currentSource = null; // Track the currently playing source

        // --- Web Audio API Initialization ---
        function initAudioContext() {
            if (!audioContext) {
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    audioContext = new AudioContext();
                    console.log("AudioContext initialized.");
                } catch (e) {
                    console.error("Web Audio API is not supported in this browser:", e);
                    displayMessage('error', 'Web Audio API is not supported in this browser.');
                    playButton.disabled = true; // Disable button if API not supported
                }
            }
             // Resume context on user interaction if needed (good practice)
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // --- Display Messages ---
        function displayMessage(type, message) {
            statusArea.textContent = message;
            statusArea.className = 'mt-4 p-3 text-center text-sm rounded-md min-h-[40px]'; // Reset classes
            if (type === 'error') {
                statusArea.classList.add('bg-red-100', 'text-red-700');
            } else if (type === 'success') {
                statusArea.classList.add('bg-green-100', 'text-green-700');
            } else if (type === 'info') {
                statusArea.classList.add('bg-blue-100', 'text-blue-700');
            } else if (type === 'loading') {
                statusArea.innerHTML = `<span class="spinner"></span> ${message}`; // Add spinner
                statusArea.classList.add('bg-yellow-100', 'text-yellow-700');
            }
        }

        // --- Base64 Decoding and PCM Conversion ---
        function decodeAndPrepareAudio() {
            initAudioContext(); // Ensure context is ready
            if (!audioContext) return; // Exit if context failed to initialize

            const base64Data = base64Input.value.trim();
            const sampleRate = parseInt(sampleRateInput.value, 10);
            const numChannels = parseInt(channelsInput.value, 10);
            const format = bitDepthInput.value;

            // --- Input Validation ---
            if (!base64Data) {
                displayMessage('error', 'Please paste Base64 audio data.');
                return;
            }
            if (isNaN(sampleRate) || sampleRate <= 0) {
                displayMessage('error', 'Invalid Sample Rate. Please enter a positive number.');
                return;
            }
            if (isNaN(numChannels) || (numChannels !== 1 && numChannels !== 2)) {
                displayMessage('error', 'Invalid number of channels. Select 1 or 2.');
                return;
            }

            displayMessage('loading', 'Decoding Base64 data...');
            playButton.disabled = true;

            // Use setTimeout to allow the UI to update before potentially heavy decoding
            setTimeout(() => {
                try {
                    // 1. Decode Base64
                    const binaryString = atob(base64Data);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const audioDataBuffer = bytes.buffer; // Get the underlying ArrayBuffer

                    // 2. Determine bytes per sample and sample count
                    let bytesPerSample = 0;
                    if (format === '8u') bytesPerSample = 1;
                    else if (format === '16s') bytesPerSample = 2;
                    else if (format === '32f') bytesPerSample = 4;
                    else {
                        throw new Error("Unsupported bit depth/format selected.");
                    }

                    const totalSamples = len / bytesPerSample;
                    const frameCount = totalSamples / numChannels;

                    if (len % (bytesPerSample * numChannels) !== 0) {
                         console.warn(`Warning: Data length (${len} bytes) is not perfectly divisible by bytes per sample (${bytesPerSample}) and channels (${numChannels}). There might be trailing data.`);
                    }
                    if (!Number.isInteger(frameCount)) {
                         throw new Error(`Calculated frame count (${frameCount}) is not an integer. Check parameters or data integrity.`);
                    }


                    displayMessage('info', `Decoded ${len} bytes. Processing ${frameCount.toFixed(0)} frames...`);


                    // 3. Create AudioBuffer
                    const audioBuffer = audioContext.createBuffer(numChannels, frameCount, sampleRate);

                    // 4. Fill AudioBuffer with PCM data (converting and de-interleaving)
                    const dataView = new DataView(audioDataBuffer);
                    let offset = 0;
                    const littleEndian = true; // Assume Little Endian for 16s and 32f

                    for (let channel = 0; channel < numChannels; channel++) {
                        const channelData = audioBuffer.getChannelData(channel);
                        offset = channel * bytesPerSample; // Start offset for this channel in the first frame

                        for (let i = 0; i < frameCount; i++) {
                            let sampleValue = 0;
                            const currentOffset = i * numChannels * bytesPerSample + offset;

                            // Ensure we don't read past the buffer boundary
                            if (currentOffset + bytesPerSample > audioDataBuffer.byteLength) {
                                console.warn(`Attempted to read past buffer boundary at frame ${i}, channel ${channel}. Filling with 0.`);
                                sampleValue = 0; // Or handle as appropriate
                            } else {
                                // Read and convert sample based on format
                                if (format === '8u') {
                                    // 8-bit Unsigned Integer: 0 to 255 -> -1.0 to +1.0
                                    sampleValue = (dataView.getUint8(currentOffset) - 128) / 128.0;
                                } else if (format === '16s') {
                                    // 16-bit Signed Integer: -32768 to 32767 -> -1.0 to +1.0
                                    sampleValue = dataView.getInt16(currentOffset, littleEndian) / 32768.0;
                                } else if (format === '32f') {
                                    // 32-bit Float: Assumed to be in -1.0 to 1.0 range already
                                    sampleValue = dataView.getFloat32(currentOffset, littleEndian);
                                }
                            }


                            // Clamp values just in case they exceed the expected range
                            channelData[i] = Math.max(-1.0, Math.min(1.0, sampleValue));
                        }
                    }

                    // 5. Play the buffer
                    playAudioBuffer(audioBuffer);

                } catch (error) {
                    console.error("Error decoding or processing audio:", error);
                    displayMessage('error', `Error: ${error.message}`);
                    playButton.disabled = false; // Re-enable button on error
                }
            }, 50); // Small delay for UI update
        }

        // --- Audio Playback ---
        function playAudioBuffer(audioBuffer) {
            if (!audioContext) return;

             // Stop any previously playing source
            if (currentSource) {
                try {
                    currentSource.stop();
                    currentSource.disconnect(); // Disconnect from destination
                } catch(e) {
                    console.warn("Could not stop previous source:", e);
                }
                currentSource = null;
            }


            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);

            source.onended = () => {
                displayMessage('success', `Playback finished. Duration: ${audioBuffer.duration.toFixed(2)}s`);
                playButton.disabled = false; // Re-enable button after playback
                currentSource = null;
            };

            source.start(0); // Play immediately
            currentSource = source; // Track the new source

            displayMessage('info', `Playing audio... (${audioBuffer.duration.toFixed(2)}s)`);
            // Keep button disabled while playing
        }

        // --- Event Listener ---
        playButton.addEventListener('click', decodeAndPrepareAudio);

        // Optional: Initialize AudioContext on first user interaction
        // document.body.addEventListener('click', initAudioContext, { once: true });
        // Or initialize directly if preferred (might show a warning in some browsers)
         initAudioContext();


    </script>

</body>
</html>
